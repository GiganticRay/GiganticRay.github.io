<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/01/27/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-01-27T12:35:45.162Z" itemprop="datePublished">2025-01-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/01/27/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/01/27/hello-world/" data-id="cm6f1kwxr000cmsusfc9j9art" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-conditional-Number-of-Matrix" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/11/conditional-Number-of-Matrix/" class="article-date">
  <time class="dt-published" datetime="2021-01-10T16:00:00.000Z" itemprop="datePublished">2021-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/11/conditional-Number-of-Matrix/">Lei Chao&#39;s Blog</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Conditional-Number-of-Matrix"><a href="#Conditional-Number-of-Matrix" class="headerlink" title="Conditional Number of Matrix"></a>Conditional Number of Matrix</h1><blockquote>
</blockquote>
<p>In This post, I will comb the inference of the conditional number of Matrix</p>
<h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h2><blockquote>
</blockquote>
<p>不得不说，咱们语言文化的博大精深。所谓“千里之堤，溃于蚁穴”，则正是<strong>条件数</strong>的表示，旨在对某件事物进行轻微的扰动，那么其会产生巨大的影响。</p>
<h3 id="Defenition"><a href="#Defenition" class="headerlink" title="Defenition"></a>Defenition</h3><p>所以对于方程组 $Ax&#x3D;b$， 如果我们给$A$一个轻微的扰动，其解x变化仍在我们可接受的范围之内的话，那么就说这个矩阵是良好的矩阵(Well Done!)，否则，它就是一个病态的矩阵。</p>
<blockquote>
</blockquote>
<p>针对上述定义，我们引出两个问题</p>
<li>什么是轻微的扰动？
</li>
<li>如何评测一个矩阵是否是病态的？
</li>

<p>所谓轻微的扰动，并不是指整个矩阵中所有元素变化量的大小，而是说变化元素的个数。通常，我们用</p>
<p>来表示仅在$(i, j)$位置的元素为$\alpha$，其余位置为$0$的矩阵。而轻微扰动，即在$A$的基础之上 append 一些$(1)$的元素。</p>
<p>下面进行条件数的推导。</p>
<h2 id="Inference-of-the-Conditional-Number"><a href="#Inference-of-the-Conditional-Number" class="headerlink" title="Inference of the Conditional Number"></a>Inference of the Conditional Number</h2><h3 id="Neumann-Series"><a href="#Neumann-Series" class="headerlink" title="Neumann Series"></a>Neumann Series</h3><p>在这里只能说诺伊曼牛逼, If $\lim_{n \to \infty} A^n&#x3D;0$, 那么$I-A$就是非奇异的，并且</p>
<p>这个直接相乘即可验证出来了，诺伊曼给了我们一个估算$(I-A)^{-1}$的级数，太棒了。</p>
<h3 id="Perturbation-Term"><a href="#Perturbation-Term" class="headerlink" title="Perturbation Term"></a>Perturbation Term</h3><p>现在我们假设给予$A$矩阵一些轻微的扰动$B$， 即$A+B$，现在来考虑$Ax&#x3D;b$的解$x$，与$(A+B)\widetilde{x}&#x3D;b$的解$\widetilde{x}$的gap。因为$A$可逆，且$B$是轻微扰动，所以说$A+B$是可逆的，所以</p>
<p>从而，我们仅要看$A^{-1}$与$(A+B)^{-1}$的差异即可。下面由诺伊曼级数进行导出。</p>
<p>假设$\lim_{n \to \infty}(A^{-1}B)^n&#x3D;0$，(这个其实很好满足嘛，直觉上只要$A^{-1}$不要太大就好，因为$B$是轻微扰动项，所以说$B^n$本身很小很小的，这样说不太严谨，但是intuitive)。</p>
<p>为了方便起见，我们仅考虑其一阶估计</p>
<p>可见，右边儿的第二项就是扰动项：$A^{-1}BA^{-1}$。</p>
<h3 id="扰动项-条件数"><a href="#扰动项-条件数" class="headerlink" title="扰动项 &#x3D;&gt; 条件数"></a>扰动项 &#x3D;&gt; 条件数</h3><p>首先我们先得到$x- \widetilde{x}$的上界</p>
<p>这肯定是上界嘛，因为只估算到了一阶。那么，<strong>只要这个上界足够小，那么其误差就可能大</strong>。</p>
<p>由于解本身有大有小，所以我们不能直接用其差值进行误差的估量，进而采用</p>
<p>其中，由于B是扰动，所以 $\frac{\left |B \right |} {\left |A \right |}$本身很小，所以其上界如果很大，那么肯定是$\kappa$出了问题。</p>
<p>我们称$\kappa$为矩阵$A$的条件数。如果$\kappa$很小，那么其差值上界定然小，如果$\kappa$很大，那么其差值上界就很大，从而其真实的差值就可能大，就是病态矩阵。（注意定然和可能）。</p>
<p>至于这个“小”还是“大”，因为已经经过模的规范化了，所以不同矩阵之间也可以比较。</p>
<h3 id="条件数为多少时才是凉态的？"><a href="#条件数为多少时才是凉态的？" class="headerlink" title="条件数为多少时才是凉态的？"></a>条件数为多少时才是凉态的？</h3><p>这里其实可以做一个实验，编写代码画图，构造一些指定条件数的矩阵出来，观察其轻微扰动之后的差值。给出网友的结论：（第一步骤实验！）</p>
<p><strong>首先奇异和病态没有必然的联系，良态、病态、条件数都要针对求解的问题而言，比如说矩阵求逆的性态和矩阵求特征值的性态就完全是两码事 　在2-范数扰动的意义下，矩阵求逆或者解线性方程组的时候奇异矩阵可以认为是最病态（无限病态）的矩阵，因为它有零奇异值（注意，这个问题的性态体现在奇异值而不是特征值） 　至于什么样的矩阵算病态，没有绝对的标准，因为大和小是相对的概念 　通常病态与否也与实际计算的机器精度有关，比如IEEE单精度下K&#x3D;10^4算比较病态了，但在IEEE双精度下就算比较良态</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/11/conditional-Number-of-Matrix/" data-id="cm6f1kwxr0009msusdadi2ovh" data-title="Lei Chao&#39;s Blog" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Understand-Fourier-Transformation-by-basic-math" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/07/Understand-Fourier-Transformation-by-basic-math/" class="article-date">
  <time class="dt-published" datetime="2020-11-06T16:00:00.000Z" itemprop="datePublished">2020-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/07/Understand-Fourier-Transformation-by-basic-math/">Lei Chao&#39;s Blog</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Fourier"><a href="#Fourier" class="headerlink" title="Fourier"></a>Fourier</h1><blockquote>
</blockquote>
<p>从基础数学的角度理解傅里叶变换</p>
<h2 id="Foundamental-Mathematics"><a href="#Foundamental-Mathematics" class="headerlink" title="Foundamental Mathematics"></a>Foundamental Mathematics</h2><blockquote>
</blockquote>
<p>以下来自 <a target="_blank" rel="noopener" href="https://betterexplained.com/">https://betterexplained.com/</a></p>
<ol>
- 自然数E是所有增量的[**基数**](https://betterexplained.com/articles/an-intuitive-guide-to-exponential-functions-e/)，如果指数为虚数即表示旋转。
<li>[**Euler’s Formula**](https://betterexplained.com/articles/intuitive-understanding-of-eulers-formula/)表示的含义是啥，即分别从**增量**的形式，**grid**的形式，描述**圆周运动**。<script type="math/tex; mode=display">
\begin{equation}\label{1}
 e^{ix}=\cos{(x)} + i\sin{(x)}
\end{equation}</script><h2 id="傅里叶变换是干啥的">[](#傅里叶变换是干啥的)傅里叶变换是干啥的</h2>先阅读以下[这里](https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/)，用一句表示就是，我们可以借助傅里叶变换将收集到的信号分离成频率为(0hz,1hz…N-1hz)的正弦波。<h2 id="手写推导">[](#手写推导)手写推导</h2></li>
</ol>


<ol>
<li>自然数E是所有增量的<a target="_blank" rel="noopener" href="https://betterexplained.com/articles/an-intuitive-guide-to-exponential-functions-e/"><strong>基数</strong></a>，如果指数为虚数即表示旋转。</li>
</ol>
<li>[**Euler’s Formula**](https://betterexplained.com/articles/intuitive-understanding-of-eulers-formula/)表示的含义是啥，即分别从**增量**的形式，**grid**的形式，描述**圆周运动**。<script type="math/tex; mode=display">
\begin{equation}\label{1}
 e^{ix}=\cos{(x)} + i\sin{(x)}
\end{equation}</script><h2 id="傅里叶变换是干啥的">[](#傅里叶变换是干啥的)傅里叶变换是干啥的</h2>先阅读以下[这里](https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/)，用一句表示就是，我们可以借助傅里叶变换将收集到的信号分离成频率为(0hz,1hz…N-1hz)的正弦波。<h2 id="手写推导">[](#手写推导)手写推导</h2></li>

<h1 id="About-Matrix"><a href="#About-Matrix" class="headerlink" title="About Matrix"></a>About Matrix</h1><h1 id="About-Algorithm-Design"><a href="#About-Algorithm-Design" class="headerlink" title="About Algorithm Design"></a>About Algorithm Design</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/07/Understand-Fourier-Transformation-by-basic-math/" data-id="cm6f1kwxq0008msus8zsva3yq" data-title="Lei Chao&#39;s Blog" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-从不变子空间到-良好的矩阵表示" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/24/%E4%BB%8E%E4%B8%8D%E5%8F%98%E5%AD%90%E7%A9%BA%E9%97%B4%E5%88%B0-%E8%89%AF%E5%A5%BD%E7%9A%84%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA/" class="article-date">
  <time class="dt-published" datetime="2020-10-23T16:00:00.000Z" itemprop="datePublished">2020-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/10/24/%E4%BB%8E%E4%B8%8D%E5%8F%98%E5%AD%90%E7%A9%BA%E9%97%B4%E5%88%B0-%E8%89%AF%E5%A5%BD%E7%9A%84%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA/">Lei Chao&#39;s Blog</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><blockquote>
</blockquote>
<p>听君一席话，在下如拨云见日，茅塞顿开啊（\狗头，可怜的楚团长）.本文符号记法随前文。上回提到，任何一个<strong>从$U-&gt;V$空间的线性变换T</strong>，在给定$U、V$的基$B、B’$之后，都有其矩阵表示$[T]_{BB’}$。现我们给出约束：</p>
<ol>
- 输入空间**等于**输出空间：$U=V=R^{n}$。
- 输入空间的基**等于**输出空间的基：$B=B’$。<br/>那么，如果$T$在$B=B’=B_{1}$的矩阵为$[T]_{B_1}$，$T$在$B=B’=B_{2}$的矩阵为$[T]_{B_2}$，记$P=[I]_{B_1B_2}$则<br/>\begin{equation}\label{1}<br/> [T]_{B_1} = P^{-1}[T]_{B_1}P<br/>\end{equation}<br/>而我们知道，**对角矩阵**就是线性代数的神，其拥有很多良好的性质，所以我们可不可以选择一组基，使得该线性变换的矩阵为对角矩阵呢？
</ol>
这里先给结论：在结合上述约束的情况下，如果线性变换的矩阵有n个特征向量，那么就可以选择一组合适的基，使得该线性变换的矩阵表示为对角矩阵。


<h2 id="Invariant-Subspaces"><a href="#Invariant-Subspaces" class="headerlink" title="Invariant Subspaces"></a>Invariant Subspaces</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><blockquote>
</blockquote>
<p>给定$U&#x3D;V, \chi \subseteq V$， $\chi&#x3D;R^{r}.r \leqslant n$，$T$是$V$上的线性算子，如果<br/>\begin{equation}\label{2}<br/>    T(\chi)&#x3D; \chi<br/>\end{equation}<br/>我们就称$\chi$是$V$中$T$下的<strong>不变子空间</strong>。说人话就是，$T$作用在$\chi$中的任一元素后，结果仍然在$\chi$中。</p>
<h3 id="Restricted-Operator"><a href="#Restricted-Operator" class="headerlink" title="Restricted Operator"></a>Restricted Operator</h3><blockquote>
</blockquote>
<p>有了不变子空间的定义后我们很自然地可以引入<strong>restricted operator</strong>，由于$T$作用在$\chi$上与$V$中的其他元素无关，那么就好像$\chi$是一个baby $V$，我们定义一个只作用在$\chi$上的作用相同的变换$T_{&#x2F;\chi}$。此即<strong>restricted operator</strong>。</p>
<h4 id="The-matrix-representation-of-restricted-operator">[](#The-matrix-representation-of-restricted-operator)The matrix representation of restricted operator</h4>定义$\chi$的一组基为$B_x={x_1,x_2···x_r}$，故，根据线性变换基的矩阵表示的定义，可得：<br/>\begin{equation}\label{3}<br/>    [A/\chi]_{B_x} = ([A/\chi(x_1)]_{B_x}|[A/\chi(x_2)]_{B_x}|···|[A/\chi(x_r)]_{B_x}])<br/>\end{equation}


<h3 id="The-matrix-of-T-involved-T-chi"><a href="#The-matrix-of-T-involved-T-chi" class="headerlink" title="The matrix of $T$ involved $T&#x2F;\chi$"></a>The matrix of $T$ involved $T&#x2F;\chi$</h3><blockquote>
</blockquote>
<p>如果我们把$\chi$的基$B_x$作为$V$输入基$B$的一部分，那么此时的$[T]_B$的形式是怎样的呢？emm..interesting.<br/>令$B&#x3D;(x_1,x_2…x_r,y_1,y_2…y_q)$是$V$的一组基，那么，<br/>\begin{equation}\label{4}<br/>    [T]_B&#x3D;([T(x_1)]_B|···|[T(x_r)]_B|[T(q_1)]_B···|[T(y_q)]_B)<br/>\end{equation}</p>
<p>由于$x_1-&gt;x_r$是<strong>不依赖</strong>于后面的$y$的，所以<br/>\begin{equation}\label{5}<br/>\begin{matrix}<br/>T(x_j)&#x3D;\sum_{i&#x3D;1}^{r}\alpha_{ij}x_i &amp;<br/>[T(x_j)]<em>B &#x3D; \begin{pmatrix}<br/>\alpha</em>{1j}\<br/>···\<br/>\alpha{rj}\<br/>0\<br/>···\<br/>0<br/>\end{pmatrix}\end{matrix}<br/>\end{equation}</p>
<p>\begin{equation}\label{6}<br/>\begin{matrix}<br/>T(y_j)&#x3D;\sum_{i&#x3D;1}^{r}\beta_{ij}x_i + \sum_{i&#x3D;1}^{q}\gamma_{ij}y_i &amp;<br/>[T(y_j)]<em>B &#x3D; \begin{pmatrix}<br/>\beta</em>{1j}\<br/>···\<br/>\beta_{rj}\<br/>\gamma_{1j}\<br/>···\<br/>\gamma_{qj}<br/>\end{pmatrix}\end{matrix}<br/>\end{equation}</p>
<blockquote>
</blockquote>
<p>从而，可得出：<br/>\begin{equation}\label{7}<br/>    [T]<em>B &#x3D;<br/>    \begin{pmatrix}<br/>    \alpha</em>{11} &amp; ··· &amp; \alpha_{1r} &amp; \beta_{11} &amp; ··· &amp; \beta_{1q}\<br/>     ·&amp; ··· &amp; · &amp; · &amp; ··· &amp; ·\<br/>    \alpha_{r1} &amp; ··· &amp; \alpha_{rr} &amp; \beta_{r1} &amp; ··· &amp; \beta_{rq}\<br/>     0&amp; ··· &amp; 0 &amp; \gamma_{11} &amp; ··· &amp; \gamma_{1q}\<br/>     ·&amp; ··· &amp; · &amp; · &amp; ··· &amp; ·\<br/>     0&amp; ··· &amp; 0 &amp; \gamma_{q1} &amp; ··· &amp; \gamma_{qq}<br/>    \end{pmatrix}<br/>\end{equation}<br>左上角部分即为$[T_{&#x2F;\chi}]<em>{B</em>{\chi}}$。</p>
<h3 id="联想到特征向量以及特征空间"><a href="#联想到特征向量以及特征空间" class="headerlink" title="联想到特征向量以及特征空间"></a>联想到特征向量以及特征空间</h3><blockquote>
</blockquote>
<p>上面我们已经得出一般形式，不难发现，$[T]_B$的<strong>n</strong>个特征向量**（前面我们的约束）<strong>，都是$T$下的不变子空间，那么有意思的来了，把这n个特征向量作为$V$的基$B&#x3D;(x_1,x_2,···,x_n)$，那么$[T]_B$的形式就是一个</strong>对角矩阵**了，对角线元素为特征值$\lambda$，interesting。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/24/%E4%BB%8E%E4%B8%8D%E5%8F%98%E5%AD%90%E7%A9%BA%E9%97%B4%E5%88%B0-%E8%89%AF%E5%A5%BD%E7%9A%84%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA/" data-id="cm6f1kwxs000emsus5ydt0fy0" data-title="Lei Chao&#39;s Blog" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Change-Of-Basis-Operator" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/20/Change-Of-Basis-Operator/" class="article-date">
  <time class="dt-published" datetime="2020-10-19T16:00:00.000Z" itemprop="datePublished">2020-10-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/10/20/Change-Of-Basis-Operator/">Lei Chao&#39;s Blog</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h2><ol>
<li>$[T]_B$表示，以$B、B$为<code>输入、输出基</code>下，$T$变换的矩阵表示</li>
<li>$[I]_{BB’}$表示分别以$B、B’$为<code>输入、输出基</code>下，$I$变换的矩阵表示。</li>
<li>$[x_1]_{B’}$表示$x_1$这个<code>object</code>在$B’$下的坐标表示。上述</li>
</ol>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><blockquote>
</blockquote>
<p>关于基变换算子的一些理解，(秃头进行中…)基变换算子是什么，我们可以用基变换算子干嘛？</p>
<ol>
- 用基变换算子，当然是对物体object进行基变换的鸭
- 探索对于同一个线性变换，在给定不同的输入基以及输出基下，其对应的矩阵有什么联系
</ol>


<h2 id="什么是基变换算子"><a href="#什么是基变换算子" class="headerlink" title="什么是基变换算子"></a>什么是基变换算子</h2><blockquote>
</blockquote>
<p>这一点是我学习时非常困扰的一点，把一切抛之于脑后，不去想基变换，就把它看成是一种变换，这样就好解释了。首先我们说明：<strong>基变换是一种线性变换</strong>，这个自己验证即可，而一个从$U-&gt;V$的线性变换是<code>客观存在的</code>，只有当我们给定$U、V$的一组基后，这个线性变换的<code>矩阵表示</code>才被确定下来。<br>我们知道，给定$U、V$空间的一组基$B&#x3D;[u_1,u_2…u_n]，B’&#x3D;[v_1,v_2…v_m]$从$U-&gt;V$空间的任意线性变换$T$，都对应着一个矩阵表示。现在我们引出一个问题：<strong>基变换也是线性变换，那么我们给定一组基$B&#x3D;[u_1,u_2…u_n]、B’&#x3D;[v_1,v_2…v_n]$,基变换是从基$B1-&gt;B1’$，请问$B、B’$与$B1、B1’$之间都是基，那他们有什么联系呢？</strong><br>这是我学习时非常非常困惑的一点，按照我的理解，这两者没有任何联系，他们所表示的内容是两个不同的概念：<br>把基变换算子就抽象出一个变换，其输入空间与输出空间都是$R^n$（管它什么基变换不变换的，就看成是一个变换），而一个线性变换要在<strong>给定输入空间的一组输入基、输出空间的一组输出基</strong>下，才能给出其唯一的矩阵表示。上面的<strong>输入、输出基</strong>，即是$B、B’$。那么可能就有人问了：<strong>“那$B1、B1’$是啥呢？”</strong>，我们只要把**$B1与B1$’**看作是这个线性变换里边儿的元素就可以了。<br>对应，李老师直接给出线性变换的定义：给定两个基$B&#x3D;(x_1,x_2…x_n)，B’&#x3D;(y_1,y_2…y_n)$。把$B$变换为$B’$的T表示为<br/>\begin{equation}\label{1}<br/>T(y_i)&#x3D;x_i<br/>\end{equation}<br>tips：上述定义之中的基$B、B’$是<code>T要变换的东西，而不是T所在的基</code>，好绕啊…</p>
<h2 id="基变换算子的作用之一"><a href="#基变换算子的作用之一" class="headerlink" title="基变换算子的作用之一"></a>基变换算子的作用之一</h2><blockquote>
</blockquote>
<p>假设$P$是一个基变换算子$T$的矩阵表示$P&#x3D;[T]<em>{BB’}$，<code>x</code>是一个<code>object</code>，其在$B$下的坐标表示为$[x]</em>{B}$，其在$B’$下的坐标表示为$[x]<em>{B’}$，那么$[x]</em>{B’}&#x3D;P·[x]_{B}$。</p>
<h2 id="基变换算子的矩阵表示是啥"><a href="#基变换算子的矩阵表示是啥" class="headerlink" title="基变换算子的矩阵表示是啥"></a>基变换算子的矩阵表示是啥</h2><blockquote>
</blockquote>
<p>不给定输入基与输出基谈变换的矩阵表示都是耍流氓，上述我们给出了基变换算子的定义，却并未给出该变换输入空间的输入基，输出空间的输出基。来看一下这个表达式</p>
<p>\begin{equation}\label{2}<br/>P&#x3D;[T]<em>{BB}&#x3D;[T]</em>{B’B’}&#x3D;[I]<em>{BB’}&#x3D;([x_1]</em>{B’}|[x_2]<em>{B’}|···|[x_n]</em>{B’})<br/>\end{equation}</p>
<blockquote>
</blockquote>
<p><strong>我个人觉得的就是，由于基变换算子太饶了，而我们可以用一个简单的形式来等价表示，即$[I]<em>{BB’}$，那我们就干脆用$[I]</em>{BB’}$来表示从B到B’的线性变换的矩阵了</strong>。</p>
<h3 id="Prove-Equation-3"><a href="#Prove-Equation-3" class="headerlink" title="Prove Equation 3"></a>Prove Equation 3</h3><blockquote>
</blockquote>
<p>根据定义，我们可以得到：</p>
<p>\begin{equation}\label{3}<br/>    T(y_i)&#x3D;x_i&#x3D;\sum_{j&#x3D;1}^n \alpha_jy_j<br/>\end{equation}</p>
<blockquote>
</blockquote>
<p>$[\alpha_1, \alpha_2···\alpha_n]$即表示$x_i$这个<code>object</code>，在$B’$下的坐标表示，即$\alpha&#x3D;[x_i]_{B’}$。现在，我们同时考虑对等式3左右两边同时进行T变换：</p>
<p>\begin{equation}\label{4}<br/>    T(x_i)&#x3D;\sum_{j&#x3D;1}^n\alpha_j·T(y_j) &#x3D; \sum_{j&#x3D;1}^n\alpha_jx_j<br/>\end{equation}</p>
<blockquote>
</blockquote>
<p>这个式子很有趣啊，表示$T(x_i)$在$B$下的坐标表示也为$\alpha$，即$\alpha&#x3D;[T(x_i)]_{B}$，结合等式3，那么就是</p>
<p>\begin{equation}\label{5}<br/>    [x_i]_{B’} &#x3D; [T(x_i)]_B<br/>\end{equation}</p>
<blockquote>
</blockquote>
<p>这样我们可以得到如下：</p>
<p>\begin{equation}\label{6}<br/>    [T]_b &#x3D; ([T(x_1)]_B,[T(x_2)]<em>B···[T(x_n)]<em>B) &#x3D; ([x_1]</em>{B’},[x_2]</em>{B’}···,[x_n]<em>B’) &#x3D; [T]</em>{B’}<br/>\end{equation}</p>
<blockquote>
</blockquote>
<p>证明$[I]_{BB’}$与他们相等也很简单</p>
<p>\begin{equation}\label{7}<br/>    [I]<em>{BB’}&#x3D;[[I(x_n)]</em>{B’},[I(x_2)]<em>{B’}···,[I(x_n)]</em>{B’}]&#x3D;[[x_1]<em>{B’},[x_2]</em>{B’}···,[x_n]<em>{B’}]&#x3D;[T]</em>{B’}<br/>\end{equation}</p>
<blockquote>
</blockquote>
<p>我靠，这也太神奇了，从而，研究从$B-&gt;B’$的基变换算子，我们就可以研究$[I]_{BB’}$这个矩阵了。</p>
<h2 id="基变换算子的作用之二"><a href="#基变换算子的作用之二" class="headerlink" title="基变换算子的作用之二"></a>基变换算子的作用之二</h2><blockquote>
</blockquote>
<p>考虑这样一种情况，$A$是在$V$上的一个线性算子<code>(linear operator)</code>，$B、B’$分别是$V$的两组基，那么$[A]<em>B$与$[A]</em>{B’}$这两个矩阵既然表示同样线性变换，<strong>那么它们有什么联系呢？</strong></p>
<p>\begin{equation}\label{8}<br/>    [A]<em>B &#x3D; P^{-1}[A]</em>{B’}P<br/>\end{equation}</p>
<blockquote>
</blockquote>
<p>where $P &#x3D; [I]_{BB’}$，这个很好理解嘛，我们把两边都乘以$[x]_B$，即</p>
<p>\begin{equation}\label{9}<br/>    [A]_B[x]<em>B &#x3D; P^{-1}[A]</em>{B’}P[x]_B<br/>\end{equation}</p>
<blockquote>
</blockquote>
<p>学废了吗？因为这个东西，所以如果我们已知一个线性变换的矩阵表示$[A]<em>B$，那么我们通过变换基，可以得到其更好的矩阵表示形式$[A]</em>{B’}$，这样在特定情况下就可以方便问题求解了。（一定要注意：线性变换是<code>客观存在</code>的，上述讨论的只是线性算子，即输入空间、输出空间是一样的。并且仅考虑输入空间、输出空间的基也是一样的。就相当于控制变量嘛，有同学可能要问了，那诸如投影算子这些呢，它们输入、输出空间肯定不一样鸭。这种情况不在我们的讨论范围之内，因为这样的话它的矩阵表示肯定不是满秩了，肯定会有维度的损失。）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/20/Change-Of-Basis-Operator/" data-id="cm6f1kwxq0007msus18a58crd" data-title="Lei Chao&#39;s Blog" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linear-Transformation补充-线性变换的矩阵表示" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/18/Linear-Transformation%E8%A1%A5%E5%85%85-%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9A%84%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA/" class="article-date">
  <time class="dt-published" datetime="2020-10-17T16:00:00.000Z" itemprop="datePublished">2020-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/10/18/Linear-Transformation%E8%A1%A5%E5%85%85-%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9A%84%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA/">Lei Chao&#39;s Blog</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><blockquote>
</blockquote>
<p>我在<a target="_blank" rel="noopener" href="https://giganticray.github.io/2020/10/14/Linear-Transformation%E8%A1%A5%E5%85%85/">上篇文章</a>中复现了李老师的证明：<strong>“在给定基下，任意线性变换都有其对应的矩阵表示”</strong>。然后关于这个矩阵表示是啥就没有写了，近些日子有些盆友(大妹子！)来问小雷同学，想着还是写出来吧，矩阵表示也蛮trivial的，just as a remainder。</p>
<h3 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h3><blockquote>
</blockquote>
<p>令$U$、$V$的基分别是{B &#x3D; u<sub>1</sub>, u<sub>2</sub>,…,u<sub>n</sub>}、{B’&#x3D;v<sub>1</sub>, v<sub>2</sub>,…,v<sub>m</sub>}。$(\xi_1, \xi_2…\xi_n)^T&#x3D;[u]_B$(tips: 即object u在基B下的坐标表示)。$T$是从$U-&gt;V$的一个线性变化。<code>目的</code>: 需要求给定基下，该变换的矩阵表示$A$。</p>
<h3 id="得出过程"><a href="#得出过程" class="headerlink" title="得出过程"></a>得出过程</h3><blockquote>
</blockquote>
<p>换句话说，即一个<code>Object</code>$u$在$U$下坐标$[u]_B &#x3D; (\xi_1, \xi_2…\xi_n)^T$，左乘$A$后$A[u]<em>B$为$u$在经过$T$变换后在$V$下的坐标表示$[u]</em>{B’} &#x3D; (\sigma_1, \sigma_2…\sigma_m)^T$。</p>
<p>\begin{equation}\label{1}<br/>u&#x3D;\xi_1u_1+\xi_2u_2···\xi_nu_n<br/>\end{equation}</p>
<blockquote>
</blockquote>
<p>我们知道</p>
<p>\begin{equation}\label{2}<br/>    T(u_1) &#x3D; \sigma_{11}v_1+\sigma_{21}v_2+···+\sigma_{m1}v_m<br/>\end{equation}<br/>\begin{equation}\label{3}<br/>    T(u_2) &#x3D; \sigma_{12}v_1+\sigma_{22}v_2+···+\sigma_{m2}v_m<br/>\end{equation}<br/>···<br/>\begin{equation}\label{4}<br/>    T(u_n) &#x3D; \sigma_{1n}v_1+\sigma_{2n}v_2+···+\sigma_{mn}v_m<br/>\end{equation}</p>
<blockquote>
</blockquote>
<p>因为$T$是线性变换，所以<br/>\begin{equation}\label{5}<br/>    T(u) &#x3D; T(\xi_1u_1)+T(\xi_2u_2)+···+T(\xi_nu_n)<br/>\end{equation}<br>根据线性变化，把它提出来，然后再展开，可以得到<br/>\begin{equation}\label{6}<br/>    T(u_1) &#x3D; \xi_1(\sigma_{11}v_1+···+\sigma_{m1}v_m) + \xi_2(\sigma_{12}v_1+···+\sigma_{m2}v_m) + \xi_n(\sigma_{1n}v_1+···+\sigma_{mn}v_m)<br/>\end{equation}<br>以$V$提出公因式<br/>\begin{equation}\label{7}<br/>    (\xi_1\sigma_{11}+\xi_2\sigma_{12}+···+\xi_n\sigma_{1n})v_1 + ··· + (\xi_1\sigma_{m1}+\xi_2\sigma_{m2}+···+\xi_n\sigma_{mn})v_m<br/>\end{equation}<br>$v_i$的系数即是变换后的<code>object</code>在$V$上的系数，写成矩阵形式，其系数为</p>
<p>$<br/>\begin{bmatrix}<br/>\sigma_{11} &amp;···  &amp;\sigma_{1n} \<br/> ···&amp; ··· &amp; ··· \<br/> \sigma_{m1}&amp; ··· &amp; \sigma_{mn}<br/>\end{bmatrix}</p>
<p>\begin{bmatrix}<br/>\xi_1\<br/>···\<br/>\xi_n<br/>\end{bmatrix}<br/>$</p>
<blockquote>
</blockquote>
<p>左边这个矩阵就是这个啦。<br/>再次强调，$T(u_1)$里面的$u_1$始终表示的对象，同理，等式右边也是对象。<code>注意我sigma下标的定义，后面自然就明白了。</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/18/Linear-Transformation%E8%A1%A5%E5%85%85-%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9A%84%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA/" data-id="cm6f1kwxp0004msushu9jedj5" data-title="Lei Chao&#39;s Blog" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linear-Transformation补充" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/14/Linear-Transformation%E8%A1%A5%E5%85%85/" class="article-date">
  <time class="dt-published" datetime="2020-10-13T16:00:00.000Z" itemprop="datePublished">2020-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/10/14/Linear-Transformation%E8%A1%A5%E5%85%85/">Lei Chao&#39;s Blog</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><blockquote>
</blockquote>
<p>今天上完liao(致敬)李保滨老师的矩阵分析课程，对线性变换有了更进一步的理解，李老师与Gilbert的课程还是有差异的，个人感觉Gilbert老师的18.06对线代的基础（4个基本子空间）讲的更透彻，而李老师再线性变换处更明了</p>
<h3 id="prerequisite"><a href="#prerequisite" class="headerlink" title="prerequisite"></a>prerequisite</h3><blockquote>
</blockquote>
<p>矩阵乘法AB&#x3D;C的意义、C的行列与A、B行列的关系、线性变换、向量空间。这要搞清楚，这里不展开。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote>
</blockquote>
<p>首先我们想一个问题，<code>如何表示一个物体</code>，其实小时候大家都做过这样的数学题，在坐标轴**（笛卡尔棒棒）<strong>上对一些坐标标点，最后把这些点连起来，最终就会得到一个可爱的猫猫啦。可见，坐标可以用来描述物体。<code>但是</code>，仅仅是坐标就足够了吗。look, here’s the deal</strong>（poor Biden…）<strong>，当然不是的，题目给出坐标时，默认了我们都在空间的标准基<code>(standard basis)</code>里。所以，除了坐标之外，我们还需要空间的基。<br>比如说，我们说一点<code>(object)</code>的<code>coordinate</code>是<code>c = (1,2,3)</code>，实际上我们默认是在说这个<code>object = c1*e1 + c2*e2 + c3*e3</code>。只是我们选择的基太<code>tricky</code>了，所以可以用<code>coordinate stand for that object directly</code></strong>(important)<strong>。<br>这样，用<code>基</code>和<code>坐标</code>,就可以表述出我们的猫猫（客观物体<code>object</code>）了。<br>tips：Gilbert的书中貌似有点说不清楚<code>object</code>与<code>coordinate</code>的关系</strong>(当然是我太菜了)**，李老师证明了：<code>在给定基下，每一个线性变换都有其矩阵表示</code>。</p>
<h3 id="Prove-在给定基下，每一个线性变换都有其矩阵表示"><a href="#Prove-在给定基下，每一个线性变换都有其矩阵表示" class="headerlink" title="Prove: 在给定基下，每一个线性变换都有其矩阵表示"></a>Prove: 在给定基下，每一个线性变换都有其矩阵表示</h3><blockquote>
</blockquote>
<p>证明思路：联想到普通情况，令{e1, e2, e3}为$R^3$的基，我们如何证明在$R^3$空间中的任一目标，都能表示出来呢？obviously，令一个系数向量C(3x1)代表坐标，一个矩阵代表基B(3x3)，那么，BC就可以唯一表示这个object了。同理，李老师的证明过程如下：</p>
<ol>
<li>$U$与$V$分别代表两个向量空间$U&#x3D;R^n$, $V&#x3D;R^m$，把从<code>U-&amp;gt;V</code>的所有线性变换放到一个集合里，记作<code>L(U, V)</code>，那么<code>L(U, V)</code>是一个向量空间。</li>
<li>令$U$、$V$的基分别是<code>B</code>&#x3D;{u<sub>1</sub>, u<sub>2</sub>,…,u<sub>n</sub>}、<code>B&#39;</code>&#x3D;{v<sub>1</sub>, v<sub>2</sub>,…,v<sub>m</sub>}。定义$T_{ji}(u)&#x3D;\xi_jv_i$，$(\xi_1, \xi_2…\xi_n)^T&#x3D;[u]_B$(tips: 即object u在基B下的坐标表示)&#96;，那么，我们可以得出下面结论3:</li>
<li>$ T_L &#x3D; \left { T_{ji}\right }_{j&#x3D;1…n}^{i&#x3D;1…m} $是<code>L(U, V)</code>的一组基。</li>
<li>如果有了结论3，那么得证。 即给定空间U、V的基，任意一个从<code>U -&amp;gt; V</code>的线性变换，我们都可以用这组基$T_L$来表示，而表示的坐标<code>coordinate</code>，即是：<strong>在U、V的给定基下，从U -&gt; V线性变换T的矩阵表示</strong>。</li>
</ol>
<h4 id="证明-T-L-left-T-ji-right-j-1…n-i-1…m-是L-U-V-的一组基"><a href="#证明-T-L-left-T-ji-right-j-1…n-i-1…m-是L-U-V-的一组基" class="headerlink" title="证明$ T_L &#x3D; \left { T_{ji}\right }_{j&#x3D;1…n}^{i&#x3D;1…m} $是L(U, V)的一组基"></a>证明$ T_L &#x3D; \left { T_{ji}\right }_{j&#x3D;1…n}^{i&#x3D;1…m} $是L(U, V)的一组基</h4><blockquote>
</blockquote>
<p>证明思路：1.$T_L$是线性无关的。2.$L(U, V)$中的任意一个元素，都能用$T_L$中的元素表示。</p>
<p>1.根据定义即证明$\sum_{j,i}\eta_{ji}T_{ji} &#x3D; 0$中的所有$\eta_{ji}只能等于0$。这个鬼东西怎么证明呢，用到了一个小trick**（tips:我这非数学专业就不去想那些老头子怎么想出来的了）**<br/>\begin{equation}\label{1}<br/>T_{ji}(u_k) &#x3D; \left{\begin{matrix}<br/> v_i &amp; j&#x3D;k\<br/> 0 &amp; j≠k<br/>\end{matrix}\right.<br/>\end{equation}</p>
<blockquote>
</blockquote>
<p>现在把要证的等式两端同时乘以$u_k$，即基组$U$的第k个基，得到<br/>\begin{equation}\label{2}<br/>(\sum_{j,i}\eta_{ji}T_{ji})(u_k) &#x3D; 0<br/>\end{equation}<br/>去括号，相当于把$u_k$做${T_{ji}}$变换。<br/>\begin{equation}\label{3}<br/>\sum_{j,i}\eta_{ji}T_{ji}(u_k) &#x3D; 0<br/>\end{equation}<br/>结合公式1，即可得出<br/>\begin{equation}\label{4}<br/>\sum_{i&#x3D;1}^{m}\eta_{ki}v_i &#x3D; 0<br/>\end{equation}<br/>因为${v_1,v_2,v_3..v_m}$是输出空间空间$V$的一组基底，所以<code>所有</code> $\eta$ <code>都等于0</code>，得证。</p>
<h4 id="要证第二个，首先要搞清楚-L-U-V-中的元素是什么-exactly。这个集合里面存放的是：从-U-V-的所有线性变换。"><a href="#要证第二个，首先要搞清楚-L-U-V-中的元素是什么-exactly。这个集合里面存放的是：从-U-V-的所有线性变换。" class="headerlink" title="要证第二个，首先要搞清楚$L(U, V)$中的元素是什么,exactly。这个集合里面存放的是：从$U$ -&gt; $V$的所有线性变换。"></a>要证第二个，首先要搞清楚$L(U, V)$中的元素是什么,exactly。这个集合里面存放的是：从$U$ -&gt; $V$的所有线性变换。</h4><blockquote>
</blockquote>
<p>现从$L(U,V)$中任取一个元素$T’$，now, enjoying this formulation,hahaha<br/>\begin{equation}\label{5}<br/>T(u) &#x3D; T(\sum_{j&#x3D;1}^{n}\xi_ju_j) &#x3D; \sum_{j&#x3D;1}^{n}\xi_jT(u_j) &#x3D; \sum_{j&#x3D;1}^{n}\xi_j \sum_{i&#x3D;1}^{m}\alpha_{ij}v_i &#x3D; \sum_{i, j}\alpha_{ij}\xi_jv_i &#x3D; \sum_{i, j}T_{ji}(u)<br/>\end{equation}<br/>非常漂亮的过程。</p>
<h4 id="现在，我们想证明的都证明完了，就可以说-在给定输入空间-U-、输出空间-V-，以及他们自个的基-B-、-B’-下，每一个从-U-到-V-的线性变换都有其矩阵表示。"><a href="#现在，我们想证明的都证明完了，就可以说-在给定输入空间-U-、输出空间-V-，以及他们自个的基-B-、-B’-下，每一个从-U-到-V-的线性变换都有其矩阵表示。" class="headerlink" title="现在，我们想证明的都证明完了，就可以说, 在给定输入空间$U$、输出空间$V$，以及他们自个的基$B$、$B’$下，每一个从$U$到$V$的线性变换都有其矩阵表示。"></a>现在，我们想证明的都证明完了，就可以说, 在给定输入空间$U$、输出空间$V$，以及他们自个的基$B$、$B’$下，每一个从$U$到$V$的线性变换都有其矩阵表示。</h4><h4 id="Brain-Expansion"><a href="#Brain-Expansion" class="headerlink" title="Brain Expansion"></a>Brain Expansion</h4><blockquote>
</blockquote>
<p>上述表述有一个flaw我没有提，你看那个第3点，为什么我们要把$T_{ji}(u)&#x3D;\xi_jv_i$, $(\xi_1, \xi_2…\xi_n)^T&#x3D;[u]<em>B$, $ T_L &#x3D; \left { T</em>{ji}\right }<em>{j&#x3D;1…n}^{i&#x3D;1…m} $作为<code>L(U, V)</code>的一组基呢，它代表着啥含义。这点老师上课也没有讲(or 我走神了?)下面我简单分析一下<br>首先我们看一下这个表达式<br/>\begin{equation}\label{6}<br/>T</em>{ji}(u_k) &#x3D; \left{\begin{matrix}<br/> v_i &amp; j&#x3D;k\<br/> 0 &amp; j≠k<br/>\end{matrix}\right.<br/>\end{equation}<br>将上面三个带入就发现这是成立的，即经过$T_{ki}$变换，$u_k$变换成了$v_i$，并且这个$T_{ki}$将其他的基$u_z(z≠k)$变成了0。穷举法，任意一个变换可能将原来空间的基$u_{1,2…n}$，变换成任意一个输出空间基的倍数$v_{1,2…m}$。所以，将这mxn<code>朴素变换</code><strong>(我瞎说的词)<strong>进行线性组合，既可以组合成任意</strong>在给定输入空间$U$、输出空间$V$，以及他们自个的基$B$、$B’$下，从$U$到$V$的线性变换</strong>。想出这个证明的人，我愿称之为现代王！</p>
<h3 id="再往下延拓就是如何将这个变换用矩阵表示出来了，具体做法也很简单，这里就不说了"><a href="#再往下延拓就是如何将这个变换用矩阵表示出来了，具体做法也很简单，这里就不说了" class="headerlink" title="再往下延拓就是如何将这个变换用矩阵表示出来了，具体做法也很简单，这里就不说了"></a>再往下延拓就是如何将这个变换用矩阵表示出来了，具体做法也很简单，这里就不说了</h3><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><blockquote>
</blockquote>
<p>我在读Gilbert<introduction algebra="" linear="" to="">的setction 8的时候，总是分不清其表达式$T(u)&#x3D;u$的这两个u到底是代表的object还是coordinate。但是李老师讲解的过程$T(u)$很明确，就是说对object u 进行 $T$变换。不过遗憾的是，李老师这堂课的视频并没有放出来，我上面的东西估计只有我自己能看懂hhh，(tips: 大家不妨试试@一下UCAS的教务处^-^)。（再tips:上课已一月有余，北京的冷空气让我的厚衣服屁用都没有了)。</introduction></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/14/Linear-Transformation%E8%A1%A5%E5%85%85/" data-id="cm6f1kwxq0005msusbm8b54ne" data-title="Lei Chao&#39;s Blog" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ubuntu搭建slurm-openmpi平台" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/08/ubuntu%E6%90%AD%E5%BB%BAslurm-openmpi%E5%B9%B3%E5%8F%B0/" class="article-date">
  <time class="dt-published" datetime="2020-09-07T16:00:00.000Z" itemprop="datePublished">2020-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/09/08/ubuntu%E6%90%AD%E5%BB%BAslurm-openmpi%E5%B9%B3%E5%8F%B0/">Lei Chao&#39;s Blog</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>目的：在初步学习之后，已了解slurm平台工作流程，slurm实则是一个计算节点之间的管理工具，其本身并无计算能力，要实现计算的功能还需另外安装mpi的实现，此处安装openMPI。</li>
<li>准备：注意版本，slurm-17.02.11；openmpi-4.0.5，这套配置能够解决依赖问题。</li>
</ul>
<h2 id="一：准备工作"><a href="#一：准备工作" class="headerlink" title="一：准备工作"></a>一：准备工作</h2><blockquote>
</blockquote>
<p>1.前三步骤见 <a target="_blank" rel="noopener" href="https://giganticray.github.io/2020/07/13/%E7%94%A8ubuntu%E6%90%AD%E5%BB%BAslurm%E5%B9%B3%E5%8F%B0/">https://giganticray.github.io/2020/07/13/%E7%94%A8ubuntu%E6%90%AD%E5%BB%BAslurm%E5%B9%B3%E5%8F%B0/</a></p>
<h2 id="二：配置slurm">[](#二：配置slurm)二：配置slurm</h2>2.配置slurm<br/>在slurm官方下载页面下载slurm（注意版本），在/opt下新建Slurm文件夹，默认是在/usr/local下的，但这样容易与其他程序搞混，故放在/opt下。二者差别可看[这里](https://qastack.cn/unix/11544/what-is-the-difference-between-opt-and-usr-local)。将下载的包解压，在解压目录执行


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. # 安装依赖</span><br><span class="line">apt-get install hwloc libhwloc-dev libmunge-dev libmunge2 munge mariadb-server libmysqlclient-dev（slave节点不需要最后两个sql）</span><br><span class="line">2. ./configure --prefix=/opt/Slurm (即指定目录安装)</span><br><span class="line">3. sudo make install</span><br><span class="line">4. # 安装完成后进入 slurm-xxxx/etc</span><br><span class="line">cp slurm.conf.example slurm.conf, 然后根据上述博客进行配置，配置完成后将slurm.conf拷贝到集群所有节点上面</span><br><span class="line">scp slurm.conf slave1@192.168.1.105:/tmp</span><br><span class="line">5. # 在slave1节点将slurm.conf文件拷贝进入安装目录</span><br><span class="line">cp /tmp/slurm.conf /home/slave1/slurmxxxx/etc</span><br><span class="line">6. 将/opt/Slurm/sbin与/opt/Slurm/bin添加进环境变量 /etc/profile</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p>配置文件解释可在<a target="_blank" rel="noopener" href="https://blog.csdn.net/datuqiqi/article/details/50827040">这里</a><br>注意，见slurm.conf中有两个slurmctld.log与slurmd.log日志文件，需要自己手动创建。到这里slurm配置完成。<br>另外，可以在&#x2F;opt&#x2F;Slurm&#x2F;sbin下执行sudo .&#x2F;slurmctld -D(主节点)。sudo .&#x2F;slurmd -D(计算节点)来验证是否成功。</p>
<h2 id="三：配置openmpi"><a href="#三：配置openmpi" class="headerlink" title="三：配置openmpi"></a>三：配置openmpi</h2><blockquote>
</blockquote>
<p>这就是为啥要选用slurm17版本的原因，slurm17x之后（具体多少搞忘了），其吧pmi.h分离了出去，我原先用slurm20版本的始终无法安装openmpi成功，吐了。<br/>在openmpi官方下载包，新建&#x2F;opt&#x2F;OpenMPI<br/><figure class="highlight plain"><table><tbody><td class="gutter"><pre>1<br/>2<br/>3<br/></pre></td><td class="code"><pre>1. 解压后在解压目录执行 <br/>2. sudo ./configure --with-pmi=/opt/Slurm/include/slurm --with-pmi-libdir=/opt/Slurm/lib --prefix=/opt/OpenMPI CPPFLAGS=-I/opt/Slurm/include/slurm LDFLAGS=-L/opt/Slurm/lib<br/>3. sudo make install<br/></pre></td></p>
</tbody></table></figure>


<h2 id="四-问题汇总"><a href="#四-问题汇总" class="headerlink" title="四: 问题汇总"></a>四: 问题汇总</h2><li>版本不匹配问题
<blockquote>
在slurm17以后，安装之后在/*/include/slurm下总是没有pmi.h，这样在安装openmpi的时候就会找不到pmi.h文件，安装失败，遂降低版本，查阅文件发现在slurm17以后，slurm官方就把pmi.h分离出来了，需要的话要另外编译，此处为了偷懒，就直接用以前的版本了。
</blockquote>
</li>
<li>openmpi编译成功后，但是在intall阶段处，出现缺少pmi.h的错误，查资料，在[这里](https://users.open-mpi.narkive.com/hCh7Xook/ompi-users-issue-compiling-openmpi-3-2-1-with-pmi-and-slurm)发现在编译openmpi的时候要另外加两个参数，遂加上，编译成功。
</li>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/08/ubuntu%E6%90%AD%E5%BB%BAslurm-openmpi%E5%B9%B3%E5%8F%B0/" data-id="cm6f1kwxs000gmsushr8o3kt0" data-title="Lei Chao&#39;s Blog" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Finite-Difference-Methods-有限差分方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/21/Finite-Difference-Methods-%E6%9C%89%E9%99%90%E5%B7%AE%E5%88%86%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-08-20T16:00:00.000Z" itemprop="datePublished">2020-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/21/Finite-Difference-Methods-%E6%9C%89%E9%99%90%E5%B7%AE%E5%88%86%E6%96%B9%E6%B3%95/">Lei Chao&#39;s Blog</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
</blockquote>
<p>最近半月都在练习驾照、Iterative methods也间断地看完了第一章（期间配合着Gilbert的Linear圣经夯实了线代的基础）。今天学习Discretization of PDES。<br>参考书籍：Iterative methods for sparse linear system</p>
<h2 id="一：初识"><a href="#一：初识" class="headerlink" title="一：初识"></a>一：初识</h2><blockquote>
</blockquote>
<p>本章大致是在讲对偏微分方程进行离散化求近似解(当然，精确解我们能够用数值计算方法计算得出)。离散化的意思是用<code>Taylor series expansion</code>，将一个方程用幂函数之和来表示。关于Taylor series的解释，<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/25627482">这个知乎问题</a>下的高赞回答简直是经典！<code>section 2.1</code>介绍了两个经典的微分方程：椭圆操作器的<code>Poisson方程</code>、<code>Convection Diffusion equation（对流扩散方程）</code>。然后2.2开始介绍<code>有限差分法</code>，根据<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E5%B7%AE%E5%88%86%E6%B3%95">维基百科</a>的定义，有限差分法即通过有限差分来近似导数、，从而求微分方程的近似解。</p>
<h2 id="二：搁置"><a href="#二：搁置" class="headerlink" title="二：搁置"></a>二：搁置</h2><p>在阅读的过程中发现对新的数学基础有要求、先修一下ma691课程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/21/Finite-Difference-Methods-%E6%9C%89%E9%99%90%E5%B7%AE%E5%88%86%E6%96%B9%E6%B3%95/" data-id="cm6f1kwxr000dmsus07bf0oxo" data-title="Lei Chao&#39;s Blog" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-A-QR-HouseHolder-Defactorization" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/07/A-QR-HouseHolder-Defactorization/" class="article-date">
  <time class="dt-published" datetime="2020-08-06T16:00:00.000Z" itemprop="datePublished">2020-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/07/A-QR-HouseHolder-Defactorization/">Lei Chao&#39;s Blog</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
</blockquote>
<p>参考章节目录</p>
<ol>
- Iteriative Methods for Sparse Linear Systems P12
- MATH 5330: Computational Methods of Linear Algebra—Lecture Note 10: Householder Transformation—Xianyi Zeng—Department of Mathematical Sciences, UTEP
</ol>


<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><blockquote>
</blockquote>
<p>关于A&#x3D;QR的分解，有三种方法：<strong><a target="_blank" rel="noopener" href="https://giganticray.github.io/2020/07/20/%E5%85%B3%E4%BA%8EA-QR-defactorization%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%A3%E9%87%8A%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">Gram、Givens</a>、Householder</strong>，Givens我不熟悉、但好像和旋转有关、可以保留A’s columns的长度。HouseHolder也有这个优点。</p>
<h2 id="大致了解"><a href="#大致了解" class="headerlink" title="大致了解"></a>大致了解</h2><blockquote>
</blockquote>
<p>Gram-Schmidt的方法是通过一步一步地将新的列A<sub>j</sub>，减去其在已正交化的q<sub>1</sub>，q<sub>2</sub>，q<sub>(j-1)</sub>的投影从而得到新的正交项以此构成Q，<strong>HouseHolder</strong>采取了另外一种完全的方法，其一步一步地将待分解矩阵A，分解成<strong>Echelon matrix</strong>，当然这个分解过程不是简单的<strong>Gaussian Decomposition</strong>，而是用了<strong>HouseHolder算子</strong>，下面翻译一下参考书目1中的分解步骤</p>
<h2 id="什么是Householder算子（Householder矩阵的几何表示）"><a href="#什么是Householder算子（Householder矩阵的几何表示）" class="headerlink" title="什么是Householder算子（Householder矩阵的几何表示）"></a>什么是Householder算子（Householder矩阵的几何表示）</h2><blockquote>
</blockquote>
<p>Householder算子是一个矩阵，其形式是<strong>P &#x3D; I - 2ww<sup>T</sup></strong>，这里我一般记作<strong>P<sub>w</sub></strong>，因为P是由w决定的，后续我们也是针对待分解矩阵的每一列来构造对应的w，从而得出针对每一列的P。<br>易证，<code>P是Ortogonal矩阵、且是Symmetric矩阵</code>：<strong>P<sup>T</sup>&#x3D;P，P<sup>T</sup>P&#x3D;I</strong>。<br>注意，我们后续在选择w的时候，要让其是2-norm unity的向量。<br>从几何上来看，Px表示的就是x,关于空间{w}<sup>⊥</sup>的镜像。画图表示就是<br/><img alt="HouseholderMatrix的几何表示" src="https://raw.githubusercontent.com/GiganticRay/lei.Blog.File/master/Picture/A%3DQR-HouseHolder/HouseholderMatrix%E7%9A%84%E5%87%A0%E4%BD%95%E8%A1%A8%E7%A4%BA.png" title="HouseholderMatrix的几何表示"/><br>v就是上文中的w、H<sub>v</sub>就是上文中的P<sub>w</sub>。</p>
<h2 id="如何为每一列Xj构造每一个HouseHolder矩阵Pj"><a href="#如何为每一列Xj构造每一个HouseHolder矩阵Pj" class="headerlink" title="如何为每一列Xj构造每一个HouseHolder矩阵Pj"></a>如何为每一列Xj构造每一个HouseHolder矩阵Pj</h2><li>针对向量x、构造其P<sub>w</sub><blockquote>
一直在强调，HouseHolder矩阵P<sub>j</sub>的作用就相当于Gaussian Elimination的消除矩阵（应该这么叫吧）。下面以第一列为例，假设第一列是x，那么目的肯定是<br/><img alt="1.15.1" src="https://raw.githubusercontent.com/GiganticRay/lei.Blog.File/master/Picture/A%3DQR-HouseHolder/1.15.1.png" title="1.15.1"/><br/>α是一个张量，后面我们会知道其实就是x的长度。现在将P的表达式代入:<br/><img alt="1.16" src="https://raw.githubusercontent.com/GiganticRay/lei.Blog.File/master/Picture/A%3DQR-HouseHolder/1.16.png" title="1.16"/><br/><img alt="推导1" src="https://raw.githubusercontent.com/GiganticRay/lei.Blog.File/master/Picture/A%3DQR-HouseHolder/%E6%8E%A8%E5%AF%BC1.png" title="推导1"/><br/><img alt="推导2" src="https://raw.githubusercontent.com/GiganticRay/lei.Blog.File/master/Picture/A%3DQR-HouseHolder/%E6%8E%A8%E5%AF%BC2.png" title="推导2"/>
</blockquote>
</li>

<blockquote>
</blockquote>
<p><strong>至此、我们就用通过x、求得了一个w，使得x在P<sub>w</sub>的作用下可以变换至||x||e<sub>1</sub></strong>，w的表达式如下<br/><img alt="w1_Expression" src="https://raw.githubusercontent.com/GiganticRay/lei.Blog.File/master/Picture/A%3DQR-HouseHolder/w1_Expression.png" title="w1_Expression"/></p>
<li>针对矩阵的每一列，进行构造P<blockquote>
先看矩阵的第一列x<sub>1</sub>，我们直接用x<sub>1</sub>替换掉`1.17`中的x，即得出w<sub>1</sub>，从而得出P<sub>1</sub>。记X<sub>1</sub>是第一次HouseHolder变换后的矩阵（形如已经完成一次Gaussian Elimination的矩阵）<br/><img alt="X1" src="https://raw.githubusercontent.com/GiganticRay/lei.Blog.File/master/Picture/A%3DQR-HouseHolder/X1.png" title="X1"/><br/>X<sub>1</sub>的第一个元素为α，其余元素为0。
</blockquote>
</li>

<blockquote>
</blockquote>
<p>现在我们看一下第<code>k</code>次HouseHolder变换的情况，操作对象当然是已经完成<code>k-1</code>次的矩阵了鸭。表达式如下：<br/><img alt="Xk" src="https://raw.githubusercontent.com/GiganticRay/lei.Blog.File/master/Picture/A%3DQR-HouseHolder/Xk.png" title="Xk"/><br>矩阵在列k-1前是一个上三角矩阵。进行下一步时，<code>前k-1列</code>保持不变，根据第<code>k</code>列的向量<strong>x<sub>k</sub></strong>，确定一个w，然后生成P。w的形状是<code>1至k-1</code>个元素都是0，这样才保证了前k-1列不变。P<sub>k</sub>的推导如下<br/><img alt="Pk" src="https://raw.githubusercontent.com/GiganticRay/lei.Blog.File/master/Picture/A%3DQR-HouseHolder/Pk.png" title="Pk"/><br>当k&#x3D;0时，即第一次变换的P，此时的<strong>β&#x3D;αe<sub>1</sub></strong>，符合上文的描述。</p>
<h2 id="构造A-QR"><a href="#构造A-QR" class="headerlink" title="构造A&#x3D;QR"></a>构造A&#x3D;QR</h2><blockquote>
</blockquote>
<p>到这里，我们就描述完了整个X的分解过程，使得x可以分解成<br/><img alt="1.22" src="https://raw.githubusercontent.com/GiganticRay/lei.Blog.File/master/Picture/A%3DQR-HouseHolder/1.22.png" title="1.22"/><br/>这里仅需要一小步、就可以将上式变成A&#x3D;QR的美丽式子了鸭。(下面这个过程，即将R那部分中的0，转移到P中去，形成Q).我们将<code>1.22</code>表示成下面的式子<code>1.23</code>，R是<code>mxm</code>的矩阵。<br/><img alt="1.23" src="https://raw.githubusercontent.com/GiganticRay/lei.Blog.File/master/Picture/A%3DQR-HouseHolder/1.23.jpg" title="1.23"/><br>我们在前面给出了P<sub>i</sub>是<code>对称、且正交</code>的，所以我们把P放到右边:<br/><img alt="1.23.1" src="https://raw.githubusercontent.com/GiganticRay/lei.Blog.File/master/Picture/A%3DQR-HouseHolder/1.23.1.png" title="1.23.1"/><br>我们用**E<sub>m</sub>**表示I的前m列，shape&#x3D;(n,m)。可表示如下<br/><img alt="1.23.2" src="https://raw.githubusercontent.com/GiganticRay/lei.Blog.File/master/Picture/A%3DQR-HouseHolder/1.23.2.png" title="1.23.2"/><br>令Q&#x3D;P<sup>T</sup>E<sub>m</sub>，这表示取P<sup>T</sup>的前m列。我们可以验证：<br/><img alt="1.23.3" src="https://raw.githubusercontent.com/GiganticRay/lei.Blog.File/master/Picture/A%3DQR-HouseHolder/1.23.3.png" title="1.23.3"/><br>所以，Q是我们想要的Q(Orthonomal)。分解成功！</p>
<h1 id="Pseudo-Code"><a href="#Pseudo-Code" class="headerlink" title="Pseudo Code"></a>Pseudo Code</h1><img alt="Householder_pseudoCode" src="https://raw.githubusercontent.com/GiganticRay/lei.Blog.File/master/Picture/A%3DQR-HouseHolder/Householder_pseudoCode.png" title="Householder_pseudoCode"/>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/07/A-QR-HouseHolder-Defactorization/" data-id="cm6f1kwxp0002msusbeg01hgf" data-title="Lei Chao&#39;s Blog" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/01/27/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/01/11/conditional-Number-of-Matrix/">Lei Chao&#39;s Blog</a>
          </li>
        
          <li>
            <a href="/2020/11/07/Understand-Fourier-Transformation-by-basic-math/">Lei Chao&#39;s Blog</a>
          </li>
        
          <li>
            <a href="/2020/10/24/%E4%BB%8E%E4%B8%8D%E5%8F%98%E5%AD%90%E7%A9%BA%E9%97%B4%E5%88%B0-%E8%89%AF%E5%A5%BD%E7%9A%84%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA/">Lei Chao&#39;s Blog</a>
          </li>
        
          <li>
            <a href="/2020/10/20/Change-Of-Basis-Operator/">Lei Chao&#39;s Blog</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>